#![feature(decl_macro)]
#[macro_use]
extern crate rocket;
#[macro_use]
extern crate itertools;

use rand::{seq::SliceRandom, thread_rng, Rng};
use regex::Regex;
use std::{
    collections::HashMap, error::Error, fs::OpenOptions, io::Read, path::PathBuf, str::FromStr,
};
use structopt::StructOpt;
use rocket::State;
use rocket::http::RawStr;
use rocket::config::{Config, Environment};
//use log::{debug, info};
use std::sync::mpsc::SyncSender;
use thiserror::Error;

// ------

#[derive(StructOpt, Debug)]
#[structopt(name = "markov")]
struct Opt {
    /// Input text file
    #[structopt(short = "i", long = "input")]
    input: Option<PathBuf>,
    /// Output length
    #[structopt(short = "l", long = "length")]
    length: Option<u32>,
}
#[derive(Clone)]
pub struct ApiPhrase<'a> {
    pub channel: String,
    length: u32,
    file_input: String,
    words: Vec<&'a str>,
    phrase: Vec<String>,
    result: Vec<&'a str>,
}

impl ApiPhrase<'_> {
    pub fn new(input: PathBuf, length: u32) -> Result<Self, String> {
    // read file and build lookup table
        let file_input = self::read_file(input).unwrap();
        let words = [].to_vec();
        let phrase = [].to_vec();
        let result = [].to_vec();

        Ok(Self {
            channel: "s".to_string(),
            length,
            file_input,
            words,
            phrase,
            result,
        })
    }

    fn read_file(filename: PathBuf) -> Result<String, Box<dyn Error>> {
        let mut file = OpenOptions::new().read(true).open(filename)?;
        let mut contents = String::new();
        file.read_to_string(&mut contents)?;
        Ok(contents)
    }

    fn splitter_words(&mut self) {
        //let spaces_re = Regex::new(r" +").unwrap();
        //let result = spaces_re.split().collect::<Vec<&str>>().clone();
        self.result = self.file_input.clone().split(" +").collect::<Vec<&str>>();
    }


    fn builder_table(&mut self, words: Vec<&str>) -> HashMap<(&str, &str), Vec<&str>> {
        let mut ret = HashMap::new();
        for (w0, w1, w2) in izip!(&words, &words[1..], &words[2..]) {
            // add w2 to the key (w0, w1)
            let current = ret.entry((*w0, *w1)).or_insert_with(Vec::new);
            current.push(*w2);
        }
        ret
    }

    pub fn run(&mut self) {
        self.splitter_words();
        rocket::ignite()
            .manage(self.phrase.clone())
            .mount("/", routes![all])
            .mount("/health/", routes![get_health],)
            .launch();
    }

    pub fn get_phrase(&mut self) -> Result<String, Box<dyn Error>> {
        // read file and build lookup table

        // pick a start location
        // pick a random start between 0 and words.len() - 3
        let mut rng = thread_rng();
        let i = rng.gen_range(0, self.words.len() - 3);

        // grab the first three words at that location
        let mut w0 = self.words[i];
        let mut w1 = self.words[i + 1];
        let mut w2 = self.words[i + 2];

        // build the lookup table - takes ownership of words!
        let lookup = self.builder_table(self.words.clone());

        // each iteration, print current word and then a space, and update our words
        for _ in 0..self.length {
            // append to output
            //print!("{} ", w2);
            self.result.push(&w2.to_string());

            // choose the next word
            w2 = &lookup[&(w0, w1)].choose(&mut rng).unwrap_or(&"NONE");
            w0 = w1;
            w1 = w2;
        }

        Ok("".to_string())
    }
}

#[derive(Clone)]
struct Phrase<'a> {
    file_input: String,
    words: Vec<&'a str>,
    result: Vec<String>,
}

fn read_file(filename: PathBuf) -> Result<String, Box<dyn Error>> {
    let mut file = OpenOptions::new().read(true).open(filename)?;
    let mut contents = String::new();
    file.read_to_string(&mut contents)?;
    Ok(contents)
}

// is there a way not to allocate this Vec?
fn split_words(w: &str) -> Vec<&str> {
    let spaces_re = Regex::new(r" +").unwrap();
    spaces_re.split(w).collect::<Vec<&str>>()
}

fn build_table(words: Vec<&str>) -> HashMap<(&str, &str), Vec<&str>> {
    let mut ret = HashMap::new();
    for (w0, w1, w2) in izip!(&words, &words[1..], &words[2..]) {
        // add w2 to the key (w0, w1)
        let current = ret.entry((*w0, *w1)).or_insert_with(Vec::new);
        current.push(*w2);
    }
    ret
}

// Unused - just to demonstrate
fn _build_table_no_itertools(words: Vec<&str>) -> HashMap<(&str, &str), Vec<&str>> {
    let mut ret = HashMap::new();
    let all_words = &words[..];
    let offset_1 = &words[1..];
    let offset_2 = &words[2..];
    for (w0, w1, w2) in all_words
        .iter()
        .zip(offset_1.iter())
        .zip(offset_2.iter())
        .map(|((x, y), z)| (x, y, z))
    {
        // add w2 to the key (w0, w1)
        let current = ret.entry((*w0, *w1)).or_insert_with(Vec::new);
        current.push(*w2);
    }
    ret
}


fn get_phrase(input: PathBuf, length: u32) -> Result<Vec<String>, Box<dyn Error>> {
    // read file and build lookup table
    let file_str = read_file(input)?;
    let words = split_words(&file_str);
    let mut result = [].to_vec();

    // pick a start location
    // pick a random start between 0 and words.len() - 3
    let mut rng = thread_rng();
    let i = rng.gen_range(0, words.len() - 3);

    // grab the first three words at that location
    let mut w0 = words[i];
    let mut w1 = words[i + 1];
    let mut w2 = words[i + 2];

    // build the lookup table - takes ownership of words!
    let lookup = build_table(words);

    // each iteration, print current word and then a space, and update our words
    for _ in 0..length {
        // append to output
        //print!("{} ", w2);
        result.push(w2.to_string());

        // choose the next word
        w2 = &lookup[&(w0, w1)].choose(&mut rng).unwrap_or(&"NONE");
        w0 = w1;
        w1 = w2;
    }

    Ok(result)
}

//fn main() {
//    let opt = Opt::from_args();
//    let filename = opt
//        .input
//        .unwrap_or_else(|| PathBuf::from_str("poetry.txt").unwrap());
//    let length = opt.length.unwrap_or(350);
//
//    if let Err(e) = run(filename, length) {
//        eprintln!("Error: {}", e);
//        ::std::process::exit(1);
//    };
//}
// ----- 
#[derive(Error, Debug)]
pub enum BrainArduinoError {
    /// It used to represent an empty source. For example, an empty text file being given
    /// as input to `count_words()`.
    /// Now it's just the most basic I dont care Error
    #[error("Source contains no data")]
    EmptyError,

    #[error("{0} is NOT installed (or something went wrong while checking that it is)")]
    ProgNotInstalledError(String),

    #[error("AvrDude could not install the program to your Arduino!")]
    AvrdudeError,

    #[error("Source contains no data")]
    IOError,
}

fn get_answer()  -> String{
    // here we'd call the other functions to get an answer
    "Nuts".to_string()
}

#[get("/")]
fn all(_phrase: State<Vec<String>>) -> String {
    get_answer()
}

#[get("/")]
fn get_health() -> String {
    "OK".to_string()
}

// curl -X POST 127.0.0.1:8000/do/test=1,test=2
#[post("/<do_stuff>")]
fn post_do(do_stuff: &RawStr, channel: State<SyncSender<String>>) -> String {
    let do_stuff_corrected = do_stuff.replace(",", "|");
    channel.send(format!("DO: {}", do_stuff_corrected.as_str())).unwrap();
    "OK".to_string()
}

fn main() {
    let opt = Opt::from_args();
    let filename = opt
        .input
        .unwrap_or_else(|| PathBuf::from_str("poetry.txt").unwrap());
    let length = opt.length.unwrap_or(10);

    let mut a = ApiPhrase::new(filename, length).unwrap();
    a.run();
}
